# -*- encoding: utf-8 -*-
"""
Contains functions to merge the records from multiple Firefox profiles.

Available functions:
 - merge_records: Accepts output database name, list of browser profiles, database table name.
        Returns Tuple of records, or writes them to disk.
"""
import os
import sqlite3

from collections import (namedtuple,
                         OrderedDict as odict
                         )
from pprint import pprint

from united_states_of_browsers.db_merge import (helpers,
                                                read_browser_db,
                                                )
from united_states_of_browsers.db_merge.imported_annotations import *

Record = []


def setup_output_db_paths(output_db: Optional[Text]) -> [PathInfo, PathInfo]:
	""" Returns paths for the database file and the file with record of processed record's hashes.
	 Accepts filename.ext for the database file to be written to.
	"""
	if output_db:
		try:
			output_db, output_ext = output_db.split(os.extsep)
		except ValueError:
			output_ext = 'sqlite'
		sink_db_path = helpers.filepath_from_another(os.extsep.join([output_db, output_ext]))
		filename_part = os.path.splitext(output_db)[0]
	else:
		import datetime
		this_moment = str(datetime.datetime.now()).split('.')[0]
		for replacee, replacer in zip(['-', ':', ' '], ['', '', '_']):
			this_moment = this_moment.replace(replacee, replacer)
		filename_part = this_moment
		sink_db_path = None
	
	filename = '_'.join(['url_hash_log', filename_part])
	url_hash_log_filename = os.path.join(filename, 'bin')
	
	url_hash_log_path = helpers.filepath_from_another(url_hash_log_filename)
	return sink_db_path, url_hash_log_path


def make_database_filenames(output_db: Union[None, Text],
                            profiles: Optional[Union[Text, Iterable[Text]]]=None
                            ) -> Dict[Text, PathInfo]:
	""" Returns dict of path of files.
	Accepts output database name and browser profiles.
	
	output_db: Union[filename.fileext, filename, None]. If None, records are not written to database file.
	profiles: Union[browser profile, list of browser profiles, None]. If None, includes all profiles.
	
	returns:
		{
		'source': Databases to read from {profile name: profile paths},
		'sink': database to write to,
		'hash': filepath to hashes of urls written,
		'source_fields': list of fieldnames in source databases
		}
	"""
	source_db_paths, source_field_names = read_browser_db.firefox(profiles=profiles)
	sink_db_path, url_hash_log_file = setup_output_db_paths(output_db)
	file_paths = {'source': source_db_paths,
	              'source_fields': source_field_names,
	              'sink': sink_db_path,
	              'hash': url_hash_log_file,
	              }
	return file_paths
	

def yield_source_records(source_db_paths: Dict[Text, PathInfo],
                         source_fieldnames: Sequence[Text]
                         ) -> Generator:
	""" Returns a generator of named tuple which can yield a record across all database files.
	Accepts dict of profile names and their database filepaths; and inclusive list of fieldnames.
	
	source_db_paths: {Profile names: profile database filepaths}
	source_fieldnames: lis of fieldnames inclusive of al the fieldnames across all database files.
	
	returns: Generator of namedtuple which can yield each record.
	"""
	global Record
	Record = namedtuple('Record', ' '.join(source_fieldnames))
	
	source_records_template = odict.fromkeys(source_fieldnames, None)
	for profile_name, profile_db_path in source_db_paths.items():
		with sqlite3.connect(profile_db_path) as source_conn:
			source_conn.row_factory = sqlite3.Row
			try:
				for db_record_yielder in source_conn.execute("""SELECT * FROM moz_places"""):
					source_records_template.update(db_record_yielder)
					yield Record(*source_records_template.values())
			except sqlite3.OperationalError:
				print(f'This browser profile does not seem to have any data: {profile_name}')
			
			
def write_new_database(sink_db_path: PathInfo,
                       fieldnames: Sequence[Text],
                       source_records: Iterable[Sequence[Text]],
                       table: Text='moz_places'
                       ) -> None:
	""" Accepts path of destination database file, list of fieldnames for each record,
	a record yielding generator.
		Optionally can accept a table name.
	
	sink_db_path: Path to the output database file.
		If None, returns the merged records instead of writing them.
	fieldnames: List of fieldnames for the output database.
		Typically autogenerated from source database.
	source_records: Generator which yields the records to be merged.
	table: name of table in the database. Default is 'moz_places'.
	"""
	sink_fieldnames = fieldnames[:]
	with sqlite3.connect(sink_db_path) as sink_conn:
		sink_queries = helpers.make_queries(table=table, field_names=', '.join(sink_fieldnames))
		try:
			sink_conn.executemany(sink_queries['insert'], source_records)
		except sqlite3.OperationalError:
			sink_conn.execute(sink_queries['create'])
			sink_conn.executemany(sink_queries['insert'], source_records)


def merge_records(output_db: Union[Text, None],
                  profiles: Union[Text, Iterable[Text], None],
                  table: Text
                  ) -> Union[None, Tuple[NamedTuple]]:
	""" Returns Tuple of records or writes them to disk.
	Accepts output database name, list of browser profiles, and database table name.
	
	output_db: Name of database file to write to.
		If None, returns the records without writing to disk.
	profiles: Name of a single profile or list of profiles to read from.
		If None, reads from all the profiles found.
	table: Name of table in database file to read from. Default is 'moz_places'.
	
	returns: Returns None if database is written to disk. Returns tuple of records otherwise.
	"""
	file_paths = make_database_filenames(output_db=output_db, profiles=profiles)
	source_records_yielder = yield_source_records(source_db_paths=file_paths['source'],
	                                              source_fieldnames=file_paths['source_fields'])
	if file_paths['sink']:
		write_new_database(sink_db_path=file_paths['sink'],
		                   table=table,
		                   fieldnames=file_paths['source_fields'],
		                   source_records=source_records_yielder
		                   )
	else:
		# return {record.url_hash: record._asdict() for record in source_records_yielder}
		return tuple(source_records_yielder)
			

if __name__ == '__main__':
	def _test():
		profiles = None
		output_db = 'test_new_allmerged.sqlite'
		table = 'moz_places'
		merge_records(output_db=output_db, profiles=profiles, table=table)
		pprint(merge_records(output_db=None, profiles=profiles, table=table))
		
		profiles = ['dev-edition-default', 'test_profile0', 'test_profile1']
		output_db = 'test_new_01_dev.sqlite'
		merge_records(output_db=output_db, profiles=profiles, table=table)
		pprint(merge_records(output_db=None, profiles=profiles, table=table))
		
		
	def _main():
		ask = input('Run database merge_records operation?\n'
		            'Press <n> to abort, <ENTER> for viewing the merged reuslts without writing it to a new database file.\n'
		            'Type a filename to write the merged results to a database file.')
		if ask.lower() == 'n':
			print('Program terminated.')
			os.sys.exit()
		elif not ask:
			pprint(merge_records(output_db=None, profiles=None, table='moz_places'))
		elif ask:
			merge_records(output_db=f'{ask}.sqlite', profiles=None, table='moz_places')
	
	
	_main()
