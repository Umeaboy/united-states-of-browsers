import sqlite3

from collections import (namedtuple,
                         OrderedDict as odict)

from united_states_of_browsers.db_merge import (helpers,
                                                read_browser_db,
                                                write_new_db,
                                                )
from united_states_of_browsers.db_merge.imported_annotations import *

Record = []


def make_database_filenames(output_db: Union[None, Text],
                            profiles: Optional[Union[Text, Iterable[Text]]]=None
                            ) -> Dict[Text, PathInfo]:
	"""
	Accepts output database name and browser profiles.
	Returns dict of path of files.
	
	:output_db: Union[filename.fileext, filename, None]. If None, records are not written to a database file.
	:profiles: Union[browser profile, list of browser profiles, None]. If None, includes all the profiles.
	
	:return:
		{
		'source': Databases to read from {profile name: profile paths},
		'sink': database to write to,
		'hash': filepath to hashes of urls written,
		'source_fields': list of fieldnames in source databases
		}
	"""
	source_db_paths, source_field_names = read_browser_db.firefox(profiles=profiles)
	sink_db_path, url_hash_log_file = write_new_db.setup_output_db_paths(output_db)
	file_paths = {'source': source_db_paths,
	              'source_fields': source_field_names,
	              'sink': sink_db_path,
	              'hash': url_hash_log_file,
	              }
	return file_paths
	

def yield_source_records(source_db_paths: Dict[Text, PathInfo],
                         source_fieldnames: Sequence[Text]
                         ) -> Generator[NamedTuple]:
	"""
	Accepts dict of profile names and their database filepaths; and inclusive list of fieldnames.
	Returns a generator of named tuple which can yield a record across all database files.
	
	:source_db_paths: {Profile names: profile database filepaths}
	:source_fieldnames: lis of fieldnames inclusive of al the fieldnames across all database files.
	
	:return: Generator of namedtuple which can yield each record.
	"""
	global Record
	Record = namedtuple('Record', ' '.join(source_fieldnames))
	
	source_records_template = odict.fromkeys(source_fieldnames, None)
	for profile_name, profile_db_path in source_db_paths.items():
		with sqlite3.connect(profile_db_path) as source_conn:
			source_conn.row_factory = sqlite3.Row
			try:
				for db_record_yielder in source_conn.execute("""SELECT * FROM moz_places"""):
					source_records_template.update(db_record_yielder)
					yield Record(*source_records_template.values())
			except sqlite3.OperationalError:
				print(f'Browser profile does not seem to have any data: {profile_name}')
			
			
def write_new_database(sink_db_path: PathInfo,
                       fieldnames: Sequence[Text],
                       source_records: Iterable[Sequence[Text]],
                       table: Text='moz_places'
                       ) -> None:
	"""
	Accepts path of destination database file, list of fieldnames for each record,
	a record yielding generator.
	Optionally can accept a table name.
	
	:sink_db_path: Path to the output database file. If None, returns the merged records instead of writing them.
	:fieldnames: List of fieldnames for the output database, usually autogenerated from soruce database files.
	:source_records: Generator which yields the records to be merged.
	:table: name of table in the database. Default is 'moz_places'.
	"""
	sink_fieldnames = fieldnames[:]
	with sqlite3.connect(sink_db_path) as sink_conn:
		sink_queries = helpers.make_queries(table=table, field_names=', '.join(sink_fieldnames))
		try:
			sink_conn.executemany(sink_queries['insert'], source_records)
		except sqlite3.OperationalError:
			sink_conn.execute(sink_queries['create'])
			sink_conn.executemany(sink_queries['insert'], source_records)


def merge(output_db: Union[Text, None],
          profiles: Union[Text, Iterable[Text], None],
          table: Text
          ) -> Union[None, Tuple[NamedTuple]]:
	"""
	Accepts output database name, list of browser profiles, and database table name.
	Returns Tuple of records or writes them to disk.
	
	:output_db: Name of database file to write to. If None, returns the records without writing to disk.
	:profiles: Name of a single profile or list of profiles to read from. If None, reads from all the profiles found.
	:table: Name of table in database file to read from. Default is 'moz_places'.
	
	:return: Returns None if database is written to disk. Returns tuple of records otherwise.
	"""
	file_paths = make_database_filenames(output_db=output_db, profiles=profiles)
	source_records_yielder = yield_source_records(source_db_paths=file_paths['source'],
	                                              source_fieldnames=file_paths['source_fields'])
	if file_paths['sink']:
		write_new_database(sink_db_path=file_paths['sink'],
		                   table=table,
		                   fieldnames=file_paths['source_fields'],
		                   source_records=source_records_yielder
		                   )
	else:
		# return {record.url_hash: record._asdict() for record in source_records_yielder}
		return tuple(source_records_yielder)
			

if __name__ == '__main__':
	from pprint import pprint
	profiles = ['dev-edition-default', 'test_profile0', 'test_profile1']
	profiles = None
	output_db = 'record_fetcher2_test_allmerged.sqlite'
	table = 'moz_places'
	merge(output_db=output_db, profiles=profiles, table=table)
	pprint(merge(output_db=None, profiles=profiles, table=table))
