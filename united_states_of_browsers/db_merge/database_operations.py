# -*- encoding: utf-8 -*-
"""
Contains functions for reading from, creating, and writing to, databases.

Avaliable functions:
 - make_database_filepaths: Returns a dict of filepaths to read from and write to.
 - yield_source_records: Uses database filepaths to yield namedtuples of records.
 - write_new_write_new_database: Creates or/and populates a database.
"""
import sqlite3
from collections import namedtuple, OrderedDict as odict

from united_states_of_browsers.db_merge import (browser_specific_setup,
                                                helpers,
                                                paths_setup
                                                )
from united_states_of_browsers.db_merge.imported_annotations import *


DBRecord = []


def make_database_filepaths(output_db: Union[None, Text],
                            profiles: Optional[Union[Text, Iterable[Text]]]=None
                            ) -> Dict[Text, PathInfo]:
	""" Returns dict of path of files.
	Accepts output database name and browser profiles.
	
	output_db: Union[filename.fileext, filename, None]. If None, records are not written to database file.
	profiles: Union[browser profile, list of browser profiles, None]. If None, includes all profiles.
	
	returns:
		{
		'source': Databases to read from {profile name: profile paths},
		'sink': database to write to,
		'hash': filepath to hashes of urls written,
		'source_fieldnames': list of fieldnames in source databases
		}
	"""
	source_db_paths, source_fieldnames, source_search_fields = browser_specific_setup.firefox(profiles=profiles)
	sink_db_path, url_hash_log_file = paths_setup.setup_output_db_paths(output_db)
	file_paths = {'source': source_db_paths,
	              'source_fieldnames': source_fieldnames,
	              'search_fieldnames': source_search_fields,
	              'sink': sink_db_path,
	              'hash': url_hash_log_file,
	              }
	return file_paths


def yield_source_records(source_db_paths: Dict[Text, PathInfo],
                         source_fieldnames: Sequence[Text]
                         ) -> Generator[NamedTuple, None, None]:
	""" Returns a generator of named tuple which can yield a record across all database files.
	Accepts dict of profile names and their database filepaths; and inclusive list of fieldnames.
	
	source_db_paths: {Profile names: profile database filepaths}
	source_fieldnames: lis of fieldnames inclusive of al the fieldnames across all database files.
	
	returns: Generator of namedtuple which can yield each record.
	"""
	global DBRecord
	DBRecord = namedtuple('DBRecord', source_fieldnames)
	
	source_records_template = odict.fromkeys(source_fieldnames, None)
	for profile_name, profile_db_path in source_db_paths.items():
		with sqlite3.connect(profile_db_path) as source_conn:
			source_conn.row_factory = sqlite3.Row
			try:
				for db_record_yielder in source_conn.execute("""SELECT * FROM moz_places"""):
					# prevents adding additional keys, only updates keys/fields specified in source_fieldnames.
					source_records_template = odict(
								(key, dict(db_record_yielder).setdefault(key, None))
									for key in source_records_template)
					yield DBRecord(*source_records_template.values())
			except sqlite3.OperationalError:
				print(f'This browser profile does not seem to have any data: {profile_name}')


def write_new_database(sink_db_path: PathInfo,
                       fieldnames: Sequence[Text],
                       source_records: Iterable[Sequence[Text]],
                       table: Text='moz_places'
                       ) -> None:
	""" Creates or/and populates a database.
	Accepts path of destination database file, list of fieldnames for each record,
	a record yielding generator.
		Optionally can accept a table name.
	
	sink_db_path: Path to the output database file.
		If None, returns the merged records instead of writing them.
	fieldnames: List of fieldnames for the output database.
		Typically autogenerated from source database.
	source_records: Generator which yields the records to be merged.
	table: name of table in the database. Default is 'moz_places'.
	"""
	sink_fieldnames = fieldnames[:]
	table = helpers.query_sanitizer(table)
	sink_fieldnames = [helpers.query_sanitizer(fieldname) for fieldname in sink_fieldnames]
	
	with sqlite3.connect(sink_db_path) as sink_conn:
		sink_queries = helpers.make_queries(table=table, field_names=', '.join(sink_fieldnames))
		try:
			sink_conn.executemany(sink_queries['insert'], source_records)
		except sqlite3.OperationalError:
			sink_conn.execute(sink_queries['create'])
			sink_conn.executemany(sink_queries['insert'], source_records)
